// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Microsoft.OpenIoT {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class OpenIoTProto {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    #endregion
    #region Extensions
    internal static readonly object Descriptor;
    static OpenIoTProto() {
      Descriptor = null;
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class OpenIoT : pb::GeneratedMessageLite<OpenIoT, OpenIoT.Builder> {
    private OpenIoT() { }
    private static readonly OpenIoT defaultInstance = new OpenIoT().MakeReadOnly();
    private static readonly string[] _openIoTFieldNames = new string[] {  };
    private static readonly uint[] _openIoTFieldTags = new uint[] {  };
    public static OpenIoT DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override OpenIoT DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override OpenIoT ThisMessage {
      get { return this; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum Command {
        REGISTER = 1,
        ACKNOWLEDGE = 2,
        DEVICELOCATION = 3,
        DEVICEALERT = 4,
        DEVICEMEASUREMENT = 5,
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Header : pb::GeneratedMessageLite<Header, Header.Builder> {
        private Header() { }
        private static readonly Header defaultInstance = new Header().MakeReadOnly();
        private static readonly string[] _headerFieldNames = new string[] { "command", "originator" };
        private static readonly uint[] _headerFieldTags = new uint[] { 8, 18 };
        public static Header DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override Header DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override Header ThisMessage {
          get { return this; }
        }
        
        public const int CommandFieldNumber = 1;
        private bool hasCommand;
        private global::Microsoft.OpenIoT.OpenIoT.Types.Command command_ = global::Microsoft.OpenIoT.OpenIoT.Types.Command.REGISTER;
        public bool HasCommand {
          get { return hasCommand; }
        }
        public global::Microsoft.OpenIoT.OpenIoT.Types.Command Command {
          get { return command_; }
        }
        
        public const int OriginatorFieldNumber = 2;
        private bool hasOriginator;
        private string originator_ = "";
        public bool HasOriginator {
          get { return hasOriginator; }
        }
        public string Originator {
          get { return originator_; }
        }
        
        public override bool IsInitialized {
          get {
            if (!hasCommand) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _headerFieldNames;
          if (hasCommand) {
            output.WriteEnum(1, field_names[0], (int) Command, Command);
          }
          if (hasOriginator) {
            output.WriteString(2, field_names[1], Originator);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasCommand) {
              size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Command);
            }
            if (hasOriginator) {
              size += pb::CodedOutputStream.ComputeStringSize(2, Originator);
            }
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasCommand) hash ^= command_.GetHashCode();
          if (hasOriginator) hash ^= originator_.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          Header other = obj as Header;
          if (other == null) return false;
          if (hasCommand != other.hasCommand || (hasCommand && !command_.Equals(other.command_))) return false;
          if (hasOriginator != other.hasOriginator || (hasOriginator && !originator_.Equals(other.originator_))) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("command", hasCommand, command_, writer);
          PrintField("originator", hasOriginator, originator_, writer);
        }
        #endregion
        
        public static Header ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Header ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Header ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Header ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Header ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Header ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Header ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Header ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Header ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Header ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Header MakeReadOnly() {
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Header prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilderLite<Header, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(Header cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Header result;
          
          private Header PrepareBuilder() {
            if (resultIsReadOnly) {
              Header original = result;
              result = new Header();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override Header MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override Header DefaultInstanceForType {
            get { return global::Microsoft.OpenIoT.OpenIoT.Types.Header.DefaultInstance; }
          }
          
          public override Header BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is Header) {
              return MergeFrom((Header) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(Header other) {
            if (other == global::Microsoft.OpenIoT.OpenIoT.Types.Header.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasCommand) {
              Command = other.Command;
            }
            if (other.HasOriginator) {
              Originator = other.Originator;
            }
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_headerFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _headerFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 8: {
                  object unknown;
                  if(input.ReadEnum(ref result.command_, out unknown)) {
                    result.hasCommand = true;
                  } else if(unknown is int) {
                  }
                  break;
                }
                case 18: {
                  result.hasOriginator = input.ReadString(ref result.originator_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasCommand {
           get { return result.hasCommand; }
          }
          public global::Microsoft.OpenIoT.OpenIoT.Types.Command Command {
            get { return result.Command; }
            set { SetCommand(value); }
          }
          public Builder SetCommand(global::Microsoft.OpenIoT.OpenIoT.Types.Command value) {
            PrepareBuilder();
            result.hasCommand = true;
            result.command_ = value;
            return this;
          }
          public Builder ClearCommand() {
            PrepareBuilder();
            result.hasCommand = false;
            result.command_ = global::Microsoft.OpenIoT.OpenIoT.Types.Command.REGISTER;
            return this;
          }
          
          public bool HasOriginator {
            get { return result.hasOriginator; }
          }
          public string Originator {
            get { return result.Originator; }
            set { SetOriginator(value); }
          }
          public Builder SetOriginator(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasOriginator = true;
            result.originator_ = value;
            return this;
          }
          public Builder ClearOriginator() {
            PrepareBuilder();
            result.hasOriginator = false;
            result.originator_ = "";
            return this;
          }
        }
        static Header() {
          object.ReferenceEquals(global::Microsoft.OpenIoT.OpenIoTProto.Descriptor, null);
        }
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Metadata : pb::GeneratedMessageLite<Metadata, Metadata.Builder> {
        private Metadata() { }
        private static readonly Metadata defaultInstance = new Metadata().MakeReadOnly();
        private static readonly string[] _metadataFieldNames = new string[] { "name", "value" };
        private static readonly uint[] _metadataFieldTags = new uint[] { 10, 18 };
        public static Metadata DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override Metadata DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override Metadata ThisMessage {
          get { return this; }
        }
        
        public const int NameFieldNumber = 1;
        private bool hasName;
        private string name_ = "";
        public bool HasName {
          get { return hasName; }
        }
        public string Name {
          get { return name_; }
        }
        
        public const int ValueFieldNumber = 2;
        private bool hasValue;
        private string value_ = "";
        public bool HasValue {
          get { return hasValue; }
        }
        public string Value {
          get { return value_; }
        }
        
        public override bool IsInitialized {
          get {
            if (!hasName) return false;
            if (!hasValue) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _metadataFieldNames;
          if (hasName) {
            output.WriteString(1, field_names[0], Name);
          }
          if (hasValue) {
            output.WriteString(2, field_names[1], Value);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasName) {
              size += pb::CodedOutputStream.ComputeStringSize(1, Name);
            }
            if (hasValue) {
              size += pb::CodedOutputStream.ComputeStringSize(2, Value);
            }
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasName) hash ^= name_.GetHashCode();
          if (hasValue) hash ^= value_.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          Metadata other = obj as Metadata;
          if (other == null) return false;
          if (hasName != other.hasName || (hasName && !name_.Equals(other.name_))) return false;
          if (hasValue != other.hasValue || (hasValue && !value_.Equals(other.value_))) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("name", hasName, name_, writer);
          PrintField("value", hasValue, value_, writer);
        }
        #endregion
        
        public static Metadata ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Metadata ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Metadata ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Metadata ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Metadata ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Metadata ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Metadata ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Metadata ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Metadata ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Metadata ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Metadata MakeReadOnly() {
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Metadata prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilderLite<Metadata, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(Metadata cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Metadata result;
          
          private Metadata PrepareBuilder() {
            if (resultIsReadOnly) {
              Metadata original = result;
              result = new Metadata();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override Metadata MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override Metadata DefaultInstanceForType {
            get { return global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.DefaultInstance; }
          }
          
          public override Metadata BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is Metadata) {
              return MergeFrom((Metadata) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(Metadata other) {
            if (other == global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasName) {
              Name = other.Name;
            }
            if (other.HasValue) {
              Value = other.Value;
            }
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_metadataFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _metadataFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasName = input.ReadString(ref result.name_);
                  break;
                }
                case 18: {
                  result.hasValue = input.ReadString(ref result.value_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasName {
            get { return result.hasName; }
          }
          public string Name {
            get { return result.Name; }
            set { SetName(value); }
          }
          public Builder SetName(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasName = true;
            result.name_ = value;
            return this;
          }
          public Builder ClearName() {
            PrepareBuilder();
            result.hasName = false;
            result.name_ = "";
            return this;
          }
          
          public bool HasValue {
            get { return result.hasValue; }
          }
          public string Value {
            get { return result.Value; }
            set { SetValue(value); }
          }
          public Builder SetValue(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasValue = true;
            result.value_ = value;
            return this;
          }
          public Builder ClearValue() {
            PrepareBuilder();
            result.hasValue = false;
            result.value_ = "";
            return this;
          }
        }
        static Metadata() {
          object.ReferenceEquals(global::Microsoft.OpenIoT.OpenIoTProto.Descriptor, null);
        }
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class RegisterDevice : pb::GeneratedMessageLite<RegisterDevice, RegisterDevice.Builder> {
        private RegisterDevice() { }
        private static readonly RegisterDevice defaultInstance = new RegisterDevice().MakeReadOnly();
        private static readonly string[] _registerDeviceFieldNames = new string[] { "hardwareId", "metadata", "siteToken", "specificationToken" };
        private static readonly uint[] _registerDeviceFieldTags = new uint[] { 10, 26, 34, 18 };
        public static RegisterDevice DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override RegisterDevice DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override RegisterDevice ThisMessage {
          get { return this; }
        }
        
        public const int HardwareIdFieldNumber = 1;
        private bool hasHardwareId;
        private string hardwareId_ = "";
        public bool HasHardwareId {
          get { return hasHardwareId; }
        }
        public string HardwareId {
          get { return hardwareId_; }
        }
        
        public const int SpecificationTokenFieldNumber = 2;
        private bool hasSpecificationToken;
        private string specificationToken_ = "";
        public bool HasSpecificationToken {
          get { return hasSpecificationToken; }
        }
        public string SpecificationToken {
          get { return specificationToken_; }
        }
        
        public const int MetadataFieldNumber = 3;
        private pbc::PopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> metadata_ = new pbc::PopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata>();
        public scg::IList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> MetadataList {
          get { return metadata_; }
        }
        public int MetadataCount {
          get { return metadata_.Count; }
        }
        public global::Microsoft.OpenIoT.OpenIoT.Types.Metadata GetMetadata(int index) {
          return metadata_[index];
        }
        
        public const int SiteTokenFieldNumber = 4;
        private bool hasSiteToken;
        private string siteToken_ = "";
        public bool HasSiteToken {
          get { return hasSiteToken; }
        }
        public string SiteToken {
          get { return siteToken_; }
        }
        
        public override bool IsInitialized {
          get {
            if (!hasHardwareId) return false;
            if (!hasSpecificationToken) return false;
            foreach (global::Microsoft.OpenIoT.OpenIoT.Types.Metadata element in MetadataList) {
              if (!element.IsInitialized) return false;
            }
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _registerDeviceFieldNames;
          if (hasHardwareId) {
            output.WriteString(1, field_names[0], HardwareId);
          }
          if (hasSpecificationToken) {
            output.WriteString(2, field_names[3], SpecificationToken);
          }
          if (metadata_.Count > 0) {
            output.WriteMessageArray(3, field_names[1], metadata_);
          }
          if (hasSiteToken) {
            output.WriteString(4, field_names[2], SiteToken);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasHardwareId) {
              size += pb::CodedOutputStream.ComputeStringSize(1, HardwareId);
            }
            if (hasSpecificationToken) {
              size += pb::CodedOutputStream.ComputeStringSize(2, SpecificationToken);
            }
            foreach (global::Microsoft.OpenIoT.OpenIoT.Types.Metadata element in MetadataList) {
              size += pb::CodedOutputStream.ComputeMessageSize(3, element);
            }
            if (hasSiteToken) {
              size += pb::CodedOutputStream.ComputeStringSize(4, SiteToken);
            }
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasHardwareId) hash ^= hardwareId_.GetHashCode();
          if (hasSpecificationToken) hash ^= specificationToken_.GetHashCode();
          foreach(global::Microsoft.OpenIoT.OpenIoT.Types.Metadata i in metadata_)
            hash ^= i.GetHashCode();
          if (hasSiteToken) hash ^= siteToken_.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          RegisterDevice other = obj as RegisterDevice;
          if (other == null) return false;
          if (hasHardwareId != other.hasHardwareId || (hasHardwareId && !hardwareId_.Equals(other.hardwareId_))) return false;
          if (hasSpecificationToken != other.hasSpecificationToken || (hasSpecificationToken && !specificationToken_.Equals(other.specificationToken_))) return false;
          if(metadata_.Count != other.metadata_.Count) return false;
          for(int ix=0; ix < metadata_.Count; ix++)
            if(!metadata_[ix].Equals(other.metadata_[ix])) return false;
          if (hasSiteToken != other.hasSiteToken || (hasSiteToken && !siteToken_.Equals(other.siteToken_))) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("hardwareId", hasHardwareId, hardwareId_, writer);
          PrintField("specificationToken", hasSpecificationToken, specificationToken_, writer);
          PrintField("metadata", metadata_, writer);
          PrintField("siteToken", hasSiteToken, siteToken_, writer);
        }
        #endregion
        
        public static RegisterDevice ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static RegisterDevice ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static RegisterDevice ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static RegisterDevice ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static RegisterDevice ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static RegisterDevice ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static RegisterDevice ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static RegisterDevice ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static RegisterDevice ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static RegisterDevice ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private RegisterDevice MakeReadOnly() {
          metadata_.MakeReadOnly();
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(RegisterDevice prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilderLite<RegisterDevice, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(RegisterDevice cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private RegisterDevice result;
          
          private RegisterDevice PrepareBuilder() {
            if (resultIsReadOnly) {
              RegisterDevice original = result;
              result = new RegisterDevice();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override RegisterDevice MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override RegisterDevice DefaultInstanceForType {
            get { return global::Microsoft.OpenIoT.OpenIoT.Types.RegisterDevice.DefaultInstance; }
          }
          
          public override RegisterDevice BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is RegisterDevice) {
              return MergeFrom((RegisterDevice) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(RegisterDevice other) {
            if (other == global::Microsoft.OpenIoT.OpenIoT.Types.RegisterDevice.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasHardwareId) {
              HardwareId = other.HardwareId;
            }
            if (other.HasSpecificationToken) {
              SpecificationToken = other.SpecificationToken;
            }
            if (other.metadata_.Count != 0) {
              result.metadata_.Add(other.metadata_);
            }
            if (other.HasSiteToken) {
              SiteToken = other.SiteToken;
            }
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_registerDeviceFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _registerDeviceFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasHardwareId = input.ReadString(ref result.hardwareId_);
                  break;
                }
                case 18: {
                  result.hasSpecificationToken = input.ReadString(ref result.specificationToken_);
                  break;
                }
                case 26: {
                  input.ReadMessageArray(tag, field_name, result.metadata_, global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.DefaultInstance, extensionRegistry);
                  break;
                }
                case 34: {
                  result.hasSiteToken = input.ReadString(ref result.siteToken_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasHardwareId {
            get { return result.hasHardwareId; }
          }
          public string HardwareId {
            get { return result.HardwareId; }
            set { SetHardwareId(value); }
          }
          public Builder SetHardwareId(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasHardwareId = true;
            result.hardwareId_ = value;
            return this;
          }
          public Builder ClearHardwareId() {
            PrepareBuilder();
            result.hasHardwareId = false;
            result.hardwareId_ = "";
            return this;
          }
          
          public bool HasSpecificationToken {
            get { return result.hasSpecificationToken; }
          }
          public string SpecificationToken {
            get { return result.SpecificationToken; }
            set { SetSpecificationToken(value); }
          }
          public Builder SetSpecificationToken(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasSpecificationToken = true;
            result.specificationToken_ = value;
            return this;
          }
          public Builder ClearSpecificationToken() {
            PrepareBuilder();
            result.hasSpecificationToken = false;
            result.specificationToken_ = "";
            return this;
          }
          
          public pbc::IPopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> MetadataList {
            get { return PrepareBuilder().metadata_; }
          }
          public int MetadataCount {
            get { return result.MetadataCount; }
          }
          public global::Microsoft.OpenIoT.OpenIoT.Types.Metadata GetMetadata(int index) {
            return result.GetMetadata(index);
          }
          public Builder SetMetadata(int index, global::Microsoft.OpenIoT.OpenIoT.Types.Metadata value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.metadata_[index] = value;
            return this;
          }
          public Builder SetMetadata(int index, global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.metadata_[index] = builderForValue.Build();
            return this;
          }
          public Builder AddMetadata(global::Microsoft.OpenIoT.OpenIoT.Types.Metadata value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.metadata_.Add(value);
            return this;
          }
          public Builder AddMetadata(global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.metadata_.Add(builderForValue.Build());
            return this;
          }
          public Builder AddRangeMetadata(scg::IEnumerable<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> values) {
            PrepareBuilder();
            result.metadata_.Add(values);
            return this;
          }
          public Builder ClearMetadata() {
            PrepareBuilder();
            result.metadata_.Clear();
            return this;
          }
          
          public bool HasSiteToken {
            get { return result.hasSiteToken; }
          }
          public string SiteToken {
            get { return result.SiteToken; }
            set { SetSiteToken(value); }
          }
          public Builder SetSiteToken(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasSiteToken = true;
            result.siteToken_ = value;
            return this;
          }
          public Builder ClearSiteToken() {
            PrepareBuilder();
            result.hasSiteToken = false;
            result.siteToken_ = "";
            return this;
          }
        }
        static RegisterDevice() {
          object.ReferenceEquals(global::Microsoft.OpenIoT.OpenIoTProto.Descriptor, null);
        }
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Acknowledge : pb::GeneratedMessageLite<Acknowledge, Acknowledge.Builder> {
        private Acknowledge() { }
        private static readonly Acknowledge defaultInstance = new Acknowledge().MakeReadOnly();
        private static readonly string[] _acknowledgeFieldNames = new string[] { "hardwareId", "message" };
        private static readonly uint[] _acknowledgeFieldTags = new uint[] { 10, 18 };
        public static Acknowledge DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override Acknowledge DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override Acknowledge ThisMessage {
          get { return this; }
        }
        
        public const int HardwareIdFieldNumber = 1;
        private bool hasHardwareId;
        private string hardwareId_ = "";
        public bool HasHardwareId {
          get { return hasHardwareId; }
        }
        public string HardwareId {
          get { return hardwareId_; }
        }
        
        public const int MessageFieldNumber = 2;
        private bool hasMessage;
        private string message_ = "";
        public bool HasMessage {
          get { return hasMessage; }
        }
        public string Message {
          get { return message_; }
        }
        
        public override bool IsInitialized {
          get {
            if (!hasHardwareId) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _acknowledgeFieldNames;
          if (hasHardwareId) {
            output.WriteString(1, field_names[0], HardwareId);
          }
          if (hasMessage) {
            output.WriteString(2, field_names[1], Message);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasHardwareId) {
              size += pb::CodedOutputStream.ComputeStringSize(1, HardwareId);
            }
            if (hasMessage) {
              size += pb::CodedOutputStream.ComputeStringSize(2, Message);
            }
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasHardwareId) hash ^= hardwareId_.GetHashCode();
          if (hasMessage) hash ^= message_.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          Acknowledge other = obj as Acknowledge;
          if (other == null) return false;
          if (hasHardwareId != other.hasHardwareId || (hasHardwareId && !hardwareId_.Equals(other.hardwareId_))) return false;
          if (hasMessage != other.hasMessage || (hasMessage && !message_.Equals(other.message_))) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("hardwareId", hasHardwareId, hardwareId_, writer);
          PrintField("message", hasMessage, message_, writer);
        }
        #endregion
        
        public static Acknowledge ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Acknowledge ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Acknowledge ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Acknowledge ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Acknowledge ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Acknowledge ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Acknowledge ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Acknowledge ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Acknowledge ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Acknowledge ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Acknowledge MakeReadOnly() {
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Acknowledge prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilderLite<Acknowledge, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(Acknowledge cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Acknowledge result;
          
          private Acknowledge PrepareBuilder() {
            if (resultIsReadOnly) {
              Acknowledge original = result;
              result = new Acknowledge();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override Acknowledge MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override Acknowledge DefaultInstanceForType {
            get { return global::Microsoft.OpenIoT.OpenIoT.Types.Acknowledge.DefaultInstance; }
          }
          
          public override Acknowledge BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is Acknowledge) {
              return MergeFrom((Acknowledge) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(Acknowledge other) {
            if (other == global::Microsoft.OpenIoT.OpenIoT.Types.Acknowledge.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasHardwareId) {
              HardwareId = other.HardwareId;
            }
            if (other.HasMessage) {
              Message = other.Message;
            }
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_acknowledgeFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _acknowledgeFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasHardwareId = input.ReadString(ref result.hardwareId_);
                  break;
                }
                case 18: {
                  result.hasMessage = input.ReadString(ref result.message_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasHardwareId {
            get { return result.hasHardwareId; }
          }
          public string HardwareId {
            get { return result.HardwareId; }
            set { SetHardwareId(value); }
          }
          public Builder SetHardwareId(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasHardwareId = true;
            result.hardwareId_ = value;
            return this;
          }
          public Builder ClearHardwareId() {
            PrepareBuilder();
            result.hasHardwareId = false;
            result.hardwareId_ = "";
            return this;
          }
          
          public bool HasMessage {
            get { return result.hasMessage; }
          }
          public string Message {
            get { return result.Message; }
            set { SetMessage(value); }
          }
          public Builder SetMessage(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasMessage = true;
            result.message_ = value;
            return this;
          }
          public Builder ClearMessage() {
            PrepareBuilder();
            result.hasMessage = false;
            result.message_ = "";
            return this;
          }
        }
        static Acknowledge() {
          object.ReferenceEquals(global::Microsoft.OpenIoT.OpenIoTProto.Descriptor, null);
        }
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class DeviceLocation : pb::GeneratedMessageLite<DeviceLocation, DeviceLocation.Builder> {
        private DeviceLocation() { }
        private static readonly DeviceLocation defaultInstance = new DeviceLocation().MakeReadOnly();
        private static readonly string[] _deviceLocationFieldNames = new string[] { "elevation", "eventDate", "hardwareId", "latitude", "longitude", "metadata" };
        private static readonly uint[] _deviceLocationFieldTags = new uint[] { 33, 41, 10, 17, 25, 50 };
        public static DeviceLocation DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override DeviceLocation DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override DeviceLocation ThisMessage {
          get { return this; }
        }
        
        public const int HardwareIdFieldNumber = 1;
        private bool hasHardwareId;
        private string hardwareId_ = "";
        public bool HasHardwareId {
          get { return hasHardwareId; }
        }
        public string HardwareId {
          get { return hardwareId_; }
        }
        
        public const int LatitudeFieldNumber = 2;
        private bool hasLatitude;
        private double latitude_;
        public bool HasLatitude {
          get { return hasLatitude; }
        }
        public double Latitude {
          get { return latitude_; }
        }
        
        public const int LongitudeFieldNumber = 3;
        private bool hasLongitude;
        private double longitude_;
        public bool HasLongitude {
          get { return hasLongitude; }
        }
        public double Longitude {
          get { return longitude_; }
        }
        
        public const int ElevationFieldNumber = 4;
        private bool hasElevation;
        private double elevation_;
        public bool HasElevation {
          get { return hasElevation; }
        }
        public double Elevation {
          get { return elevation_; }
        }
        
        public const int EventDateFieldNumber = 5;
        private bool hasEventDate;
        private ulong eventDate_;
        public bool HasEventDate {
          get { return hasEventDate; }
        }
        [global::System.CLSCompliant(false)]
        public ulong EventDate {
          get { return eventDate_; }
        }
        
        public const int MetadataFieldNumber = 6;
        private pbc::PopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> metadata_ = new pbc::PopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata>();
        public scg::IList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> MetadataList {
          get { return metadata_; }
        }
        public int MetadataCount {
          get { return metadata_.Count; }
        }
        public global::Microsoft.OpenIoT.OpenIoT.Types.Metadata GetMetadata(int index) {
          return metadata_[index];
        }
        
        public override bool IsInitialized {
          get {
            if (!hasHardwareId) return false;
            if (!hasLatitude) return false;
            if (!hasLongitude) return false;
            foreach (global::Microsoft.OpenIoT.OpenIoT.Types.Metadata element in MetadataList) {
              if (!element.IsInitialized) return false;
            }
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _deviceLocationFieldNames;
          if (hasHardwareId) {
            output.WriteString(1, field_names[2], HardwareId);
          }
          if (hasLatitude) {
            output.WriteDouble(2, field_names[3], Latitude);
          }
          if (hasLongitude) {
            output.WriteDouble(3, field_names[4], Longitude);
          }
          if (hasElevation) {
            output.WriteDouble(4, field_names[0], Elevation);
          }
          if (hasEventDate) {
            output.WriteFixed64(5, field_names[1], EventDate);
          }
          if (metadata_.Count > 0) {
            output.WriteMessageArray(6, field_names[5], metadata_);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasHardwareId) {
              size += pb::CodedOutputStream.ComputeStringSize(1, HardwareId);
            }
            if (hasLatitude) {
              size += pb::CodedOutputStream.ComputeDoubleSize(2, Latitude);
            }
            if (hasLongitude) {
              size += pb::CodedOutputStream.ComputeDoubleSize(3, Longitude);
            }
            if (hasElevation) {
              size += pb::CodedOutputStream.ComputeDoubleSize(4, Elevation);
            }
            if (hasEventDate) {
              size += pb::CodedOutputStream.ComputeFixed64Size(5, EventDate);
            }
            foreach (global::Microsoft.OpenIoT.OpenIoT.Types.Metadata element in MetadataList) {
              size += pb::CodedOutputStream.ComputeMessageSize(6, element);
            }
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasHardwareId) hash ^= hardwareId_.GetHashCode();
          if (hasLatitude) hash ^= latitude_.GetHashCode();
          if (hasLongitude) hash ^= longitude_.GetHashCode();
          if (hasElevation) hash ^= elevation_.GetHashCode();
          if (hasEventDate) hash ^= eventDate_.GetHashCode();
          foreach(global::Microsoft.OpenIoT.OpenIoT.Types.Metadata i in metadata_)
            hash ^= i.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          DeviceLocation other = obj as DeviceLocation;
          if (other == null) return false;
          if (hasHardwareId != other.hasHardwareId || (hasHardwareId && !hardwareId_.Equals(other.hardwareId_))) return false;
          if (hasLatitude != other.hasLatitude || (hasLatitude && !latitude_.Equals(other.latitude_))) return false;
          if (hasLongitude != other.hasLongitude || (hasLongitude && !longitude_.Equals(other.longitude_))) return false;
          if (hasElevation != other.hasElevation || (hasElevation && !elevation_.Equals(other.elevation_))) return false;
          if (hasEventDate != other.hasEventDate || (hasEventDate && !eventDate_.Equals(other.eventDate_))) return false;
          if(metadata_.Count != other.metadata_.Count) return false;
          for(int ix=0; ix < metadata_.Count; ix++)
            if(!metadata_[ix].Equals(other.metadata_[ix])) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("hardwareId", hasHardwareId, hardwareId_, writer);
          PrintField("latitude", hasLatitude, latitude_, writer);
          PrintField("longitude", hasLongitude, longitude_, writer);
          PrintField("elevation", hasElevation, elevation_, writer);
          PrintField("eventDate", hasEventDate, eventDate_, writer);
          PrintField("metadata", metadata_, writer);
        }
        #endregion
        
        public static DeviceLocation ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static DeviceLocation ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static DeviceLocation ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static DeviceLocation ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static DeviceLocation ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static DeviceLocation ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static DeviceLocation ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static DeviceLocation ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static DeviceLocation ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static DeviceLocation ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private DeviceLocation MakeReadOnly() {
          metadata_.MakeReadOnly();
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(DeviceLocation prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilderLite<DeviceLocation, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(DeviceLocation cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private DeviceLocation result;
          
          private DeviceLocation PrepareBuilder() {
            if (resultIsReadOnly) {
              DeviceLocation original = result;
              result = new DeviceLocation();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override DeviceLocation MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override DeviceLocation DefaultInstanceForType {
            get { return global::Microsoft.OpenIoT.OpenIoT.Types.DeviceLocation.DefaultInstance; }
          }
          
          public override DeviceLocation BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is DeviceLocation) {
              return MergeFrom((DeviceLocation) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(DeviceLocation other) {
            if (other == global::Microsoft.OpenIoT.OpenIoT.Types.DeviceLocation.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasHardwareId) {
              HardwareId = other.HardwareId;
            }
            if (other.HasLatitude) {
              Latitude = other.Latitude;
            }
            if (other.HasLongitude) {
              Longitude = other.Longitude;
            }
            if (other.HasElevation) {
              Elevation = other.Elevation;
            }
            if (other.HasEventDate) {
              EventDate = other.EventDate;
            }
            if (other.metadata_.Count != 0) {
              result.metadata_.Add(other.metadata_);
            }
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_deviceLocationFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _deviceLocationFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasHardwareId = input.ReadString(ref result.hardwareId_);
                  break;
                }
                case 17: {
                  result.hasLatitude = input.ReadDouble(ref result.latitude_);
                  break;
                }
                case 25: {
                  result.hasLongitude = input.ReadDouble(ref result.longitude_);
                  break;
                }
                case 33: {
                  result.hasElevation = input.ReadDouble(ref result.elevation_);
                  break;
                }
                case 41: {
                  result.hasEventDate = input.ReadFixed64(ref result.eventDate_);
                  break;
                }
                case 50: {
                  input.ReadMessageArray(tag, field_name, result.metadata_, global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.DefaultInstance, extensionRegistry);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasHardwareId {
            get { return result.hasHardwareId; }
          }
          public string HardwareId {
            get { return result.HardwareId; }
            set { SetHardwareId(value); }
          }
          public Builder SetHardwareId(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasHardwareId = true;
            result.hardwareId_ = value;
            return this;
          }
          public Builder ClearHardwareId() {
            PrepareBuilder();
            result.hasHardwareId = false;
            result.hardwareId_ = "";
            return this;
          }
          
          public bool HasLatitude {
            get { return result.hasLatitude; }
          }
          public double Latitude {
            get { return result.Latitude; }
            set { SetLatitude(value); }
          }
          public Builder SetLatitude(double value) {
            PrepareBuilder();
            result.hasLatitude = true;
            result.latitude_ = value;
            return this;
          }
          public Builder ClearLatitude() {
            PrepareBuilder();
            result.hasLatitude = false;
            result.latitude_ = 0D;
            return this;
          }
          
          public bool HasLongitude {
            get { return result.hasLongitude; }
          }
          public double Longitude {
            get { return result.Longitude; }
            set { SetLongitude(value); }
          }
          public Builder SetLongitude(double value) {
            PrepareBuilder();
            result.hasLongitude = true;
            result.longitude_ = value;
            return this;
          }
          public Builder ClearLongitude() {
            PrepareBuilder();
            result.hasLongitude = false;
            result.longitude_ = 0D;
            return this;
          }
          
          public bool HasElevation {
            get { return result.hasElevation; }
          }
          public double Elevation {
            get { return result.Elevation; }
            set { SetElevation(value); }
          }
          public Builder SetElevation(double value) {
            PrepareBuilder();
            result.hasElevation = true;
            result.elevation_ = value;
            return this;
          }
          public Builder ClearElevation() {
            PrepareBuilder();
            result.hasElevation = false;
            result.elevation_ = 0D;
            return this;
          }
          
          public bool HasEventDate {
            get { return result.hasEventDate; }
          }
          [global::System.CLSCompliant(false)]
          public ulong EventDate {
            get { return result.EventDate; }
            set { SetEventDate(value); }
          }
          [global::System.CLSCompliant(false)]
          public Builder SetEventDate(ulong value) {
            PrepareBuilder();
            result.hasEventDate = true;
            result.eventDate_ = value;
            return this;
          }
          public Builder ClearEventDate() {
            PrepareBuilder();
            result.hasEventDate = false;
            result.eventDate_ = 0;
            return this;
          }
          
          public pbc::IPopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> MetadataList {
            get { return PrepareBuilder().metadata_; }
          }
          public int MetadataCount {
            get { return result.MetadataCount; }
          }
          public global::Microsoft.OpenIoT.OpenIoT.Types.Metadata GetMetadata(int index) {
            return result.GetMetadata(index);
          }
          public Builder SetMetadata(int index, global::Microsoft.OpenIoT.OpenIoT.Types.Metadata value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.metadata_[index] = value;
            return this;
          }
          public Builder SetMetadata(int index, global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.metadata_[index] = builderForValue.Build();
            return this;
          }
          public Builder AddMetadata(global::Microsoft.OpenIoT.OpenIoT.Types.Metadata value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.metadata_.Add(value);
            return this;
          }
          public Builder AddMetadata(global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.metadata_.Add(builderForValue.Build());
            return this;
          }
          public Builder AddRangeMetadata(scg::IEnumerable<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> values) {
            PrepareBuilder();
            result.metadata_.Add(values);
            return this;
          }
          public Builder ClearMetadata() {
            PrepareBuilder();
            result.metadata_.Clear();
            return this;
          }
        }
        static DeviceLocation() {
          object.ReferenceEquals(global::Microsoft.OpenIoT.OpenIoTProto.Descriptor, null);
        }
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class DeviceAlert : pb::GeneratedMessageLite<DeviceAlert, DeviceAlert.Builder> {
        private DeviceAlert() { }
        private static readonly DeviceAlert defaultInstance = new DeviceAlert().MakeReadOnly();
        private static readonly string[] _deviceAlertFieldNames = new string[] { "alertMessage", "alertType", "eventDate", "hardwareId", "metadata" };
        private static readonly uint[] _deviceAlertFieldTags = new uint[] { 26, 18, 33, 10, 42 };
        public static DeviceAlert DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override DeviceAlert DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override DeviceAlert ThisMessage {
          get { return this; }
        }
        
        public const int HardwareIdFieldNumber = 1;
        private bool hasHardwareId;
        private string hardwareId_ = "";
        public bool HasHardwareId {
          get { return hasHardwareId; }
        }
        public string HardwareId {
          get { return hardwareId_; }
        }
        
        public const int AlertTypeFieldNumber = 2;
        private bool hasAlertType;
        private string alertType_ = "";
        public bool HasAlertType {
          get { return hasAlertType; }
        }
        public string AlertType {
          get { return alertType_; }
        }
        
        public const int AlertMessageFieldNumber = 3;
        private bool hasAlertMessage;
        private string alertMessage_ = "";
        public bool HasAlertMessage {
          get { return hasAlertMessage; }
        }
        public string AlertMessage {
          get { return alertMessage_; }
        }
        
        public const int EventDateFieldNumber = 4;
        private bool hasEventDate;
        private ulong eventDate_;
        public bool HasEventDate {
          get { return hasEventDate; }
        }
        [global::System.CLSCompliant(false)]
        public ulong EventDate {
          get { return eventDate_; }
        }
        
        public const int MetadataFieldNumber = 5;
        private pbc::PopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> metadata_ = new pbc::PopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata>();
        public scg::IList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> MetadataList {
          get { return metadata_; }
        }
        public int MetadataCount {
          get { return metadata_.Count; }
        }
        public global::Microsoft.OpenIoT.OpenIoT.Types.Metadata GetMetadata(int index) {
          return metadata_[index];
        }
        
        public override bool IsInitialized {
          get {
            if (!hasHardwareId) return false;
            if (!hasAlertType) return false;
            if (!hasAlertMessage) return false;
            foreach (global::Microsoft.OpenIoT.OpenIoT.Types.Metadata element in MetadataList) {
              if (!element.IsInitialized) return false;
            }
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _deviceAlertFieldNames;
          if (hasHardwareId) {
            output.WriteString(1, field_names[3], HardwareId);
          }
          if (hasAlertType) {
            output.WriteString(2, field_names[1], AlertType);
          }
          if (hasAlertMessage) {
            output.WriteString(3, field_names[0], AlertMessage);
          }
          if (hasEventDate) {
            output.WriteFixed64(4, field_names[2], EventDate);
          }
          if (metadata_.Count > 0) {
            output.WriteMessageArray(5, field_names[4], metadata_);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasHardwareId) {
              size += pb::CodedOutputStream.ComputeStringSize(1, HardwareId);
            }
            if (hasAlertType) {
              size += pb::CodedOutputStream.ComputeStringSize(2, AlertType);
            }
            if (hasAlertMessage) {
              size += pb::CodedOutputStream.ComputeStringSize(3, AlertMessage);
            }
            if (hasEventDate) {
              size += pb::CodedOutputStream.ComputeFixed64Size(4, EventDate);
            }
            foreach (global::Microsoft.OpenIoT.OpenIoT.Types.Metadata element in MetadataList) {
              size += pb::CodedOutputStream.ComputeMessageSize(5, element);
            }
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasHardwareId) hash ^= hardwareId_.GetHashCode();
          if (hasAlertType) hash ^= alertType_.GetHashCode();
          if (hasAlertMessage) hash ^= alertMessage_.GetHashCode();
          if (hasEventDate) hash ^= eventDate_.GetHashCode();
          foreach(global::Microsoft.OpenIoT.OpenIoT.Types.Metadata i in metadata_)
            hash ^= i.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          DeviceAlert other = obj as DeviceAlert;
          if (other == null) return false;
          if (hasHardwareId != other.hasHardwareId || (hasHardwareId && !hardwareId_.Equals(other.hardwareId_))) return false;
          if (hasAlertType != other.hasAlertType || (hasAlertType && !alertType_.Equals(other.alertType_))) return false;
          if (hasAlertMessage != other.hasAlertMessage || (hasAlertMessage && !alertMessage_.Equals(other.alertMessage_))) return false;
          if (hasEventDate != other.hasEventDate || (hasEventDate && !eventDate_.Equals(other.eventDate_))) return false;
          if(metadata_.Count != other.metadata_.Count) return false;
          for(int ix=0; ix < metadata_.Count; ix++)
            if(!metadata_[ix].Equals(other.metadata_[ix])) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("hardwareId", hasHardwareId, hardwareId_, writer);
          PrintField("alertType", hasAlertType, alertType_, writer);
          PrintField("alertMessage", hasAlertMessage, alertMessage_, writer);
          PrintField("eventDate", hasEventDate, eventDate_, writer);
          PrintField("metadata", metadata_, writer);
        }
        #endregion
        
        public static DeviceAlert ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static DeviceAlert ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static DeviceAlert ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static DeviceAlert ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static DeviceAlert ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static DeviceAlert ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static DeviceAlert ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static DeviceAlert ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static DeviceAlert ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static DeviceAlert ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private DeviceAlert MakeReadOnly() {
          metadata_.MakeReadOnly();
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(DeviceAlert prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilderLite<DeviceAlert, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(DeviceAlert cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private DeviceAlert result;
          
          private DeviceAlert PrepareBuilder() {
            if (resultIsReadOnly) {
              DeviceAlert original = result;
              result = new DeviceAlert();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override DeviceAlert MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override DeviceAlert DefaultInstanceForType {
            get { return global::Microsoft.OpenIoT.OpenIoT.Types.DeviceAlert.DefaultInstance; }
          }
          
          public override DeviceAlert BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is DeviceAlert) {
              return MergeFrom((DeviceAlert) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(DeviceAlert other) {
            if (other == global::Microsoft.OpenIoT.OpenIoT.Types.DeviceAlert.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasHardwareId) {
              HardwareId = other.HardwareId;
            }
            if (other.HasAlertType) {
              AlertType = other.AlertType;
            }
            if (other.HasAlertMessage) {
              AlertMessage = other.AlertMessage;
            }
            if (other.HasEventDate) {
              EventDate = other.EventDate;
            }
            if (other.metadata_.Count != 0) {
              result.metadata_.Add(other.metadata_);
            }
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_deviceAlertFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _deviceAlertFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasHardwareId = input.ReadString(ref result.hardwareId_);
                  break;
                }
                case 18: {
                  result.hasAlertType = input.ReadString(ref result.alertType_);
                  break;
                }
                case 26: {
                  result.hasAlertMessage = input.ReadString(ref result.alertMessage_);
                  break;
                }
                case 33: {
                  result.hasEventDate = input.ReadFixed64(ref result.eventDate_);
                  break;
                }
                case 42: {
                  input.ReadMessageArray(tag, field_name, result.metadata_, global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.DefaultInstance, extensionRegistry);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasHardwareId {
            get { return result.hasHardwareId; }
          }
          public string HardwareId {
            get { return result.HardwareId; }
            set { SetHardwareId(value); }
          }
          public Builder SetHardwareId(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasHardwareId = true;
            result.hardwareId_ = value;
            return this;
          }
          public Builder ClearHardwareId() {
            PrepareBuilder();
            result.hasHardwareId = false;
            result.hardwareId_ = "";
            return this;
          }
          
          public bool HasAlertType {
            get { return result.hasAlertType; }
          }
          public string AlertType {
            get { return result.AlertType; }
            set { SetAlertType(value); }
          }
          public Builder SetAlertType(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasAlertType = true;
            result.alertType_ = value;
            return this;
          }
          public Builder ClearAlertType() {
            PrepareBuilder();
            result.hasAlertType = false;
            result.alertType_ = "";
            return this;
          }
          
          public bool HasAlertMessage {
            get { return result.hasAlertMessage; }
          }
          public string AlertMessage {
            get { return result.AlertMessage; }
            set { SetAlertMessage(value); }
          }
          public Builder SetAlertMessage(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasAlertMessage = true;
            result.alertMessage_ = value;
            return this;
          }
          public Builder ClearAlertMessage() {
            PrepareBuilder();
            result.hasAlertMessage = false;
            result.alertMessage_ = "";
            return this;
          }
          
          public bool HasEventDate {
            get { return result.hasEventDate; }
          }
          [global::System.CLSCompliant(false)]
          public ulong EventDate {
            get { return result.EventDate; }
            set { SetEventDate(value); }
          }
          [global::System.CLSCompliant(false)]
          public Builder SetEventDate(ulong value) {
            PrepareBuilder();
            result.hasEventDate = true;
            result.eventDate_ = value;
            return this;
          }
          public Builder ClearEventDate() {
            PrepareBuilder();
            result.hasEventDate = false;
            result.eventDate_ = 0;
            return this;
          }
          
          public pbc::IPopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> MetadataList {
            get { return PrepareBuilder().metadata_; }
          }
          public int MetadataCount {
            get { return result.MetadataCount; }
          }
          public global::Microsoft.OpenIoT.OpenIoT.Types.Metadata GetMetadata(int index) {
            return result.GetMetadata(index);
          }
          public Builder SetMetadata(int index, global::Microsoft.OpenIoT.OpenIoT.Types.Metadata value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.metadata_[index] = value;
            return this;
          }
          public Builder SetMetadata(int index, global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.metadata_[index] = builderForValue.Build();
            return this;
          }
          public Builder AddMetadata(global::Microsoft.OpenIoT.OpenIoT.Types.Metadata value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.metadata_.Add(value);
            return this;
          }
          public Builder AddMetadata(global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.metadata_.Add(builderForValue.Build());
            return this;
          }
          public Builder AddRangeMetadata(scg::IEnumerable<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> values) {
            PrepareBuilder();
            result.metadata_.Add(values);
            return this;
          }
          public Builder ClearMetadata() {
            PrepareBuilder();
            result.metadata_.Clear();
            return this;
          }
        }
        static DeviceAlert() {
          object.ReferenceEquals(global::Microsoft.OpenIoT.OpenIoTProto.Descriptor, null);
        }
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Measurement : pb::GeneratedMessageLite<Measurement, Measurement.Builder> {
        private Measurement() { }
        private static readonly Measurement defaultInstance = new Measurement().MakeReadOnly();
        private static readonly string[] _measurementFieldNames = new string[] { "measurementId", "measurementValue" };
        private static readonly uint[] _measurementFieldTags = new uint[] { 10, 17 };
        public static Measurement DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override Measurement DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override Measurement ThisMessage {
          get { return this; }
        }
        
        public const int MeasurementIdFieldNumber = 1;
        private bool hasMeasurementId;
        private string measurementId_ = "";
        public bool HasMeasurementId {
          get { return hasMeasurementId; }
        }
        public string MeasurementId {
          get { return measurementId_; }
        }
        
        public const int MeasurementValueFieldNumber = 2;
        private bool hasMeasurementValue;
        private double measurementValue_;
        public bool HasMeasurementValue {
          get { return hasMeasurementValue; }
        }
        public double MeasurementValue {
          get { return measurementValue_; }
        }
        
        public override bool IsInitialized {
          get {
            if (!hasMeasurementId) return false;
            if (!hasMeasurementValue) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _measurementFieldNames;
          if (hasMeasurementId) {
            output.WriteString(1, field_names[0], MeasurementId);
          }
          if (hasMeasurementValue) {
            output.WriteDouble(2, field_names[1], MeasurementValue);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasMeasurementId) {
              size += pb::CodedOutputStream.ComputeStringSize(1, MeasurementId);
            }
            if (hasMeasurementValue) {
              size += pb::CodedOutputStream.ComputeDoubleSize(2, MeasurementValue);
            }
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasMeasurementId) hash ^= measurementId_.GetHashCode();
          if (hasMeasurementValue) hash ^= measurementValue_.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          Measurement other = obj as Measurement;
          if (other == null) return false;
          if (hasMeasurementId != other.hasMeasurementId || (hasMeasurementId && !measurementId_.Equals(other.measurementId_))) return false;
          if (hasMeasurementValue != other.hasMeasurementValue || (hasMeasurementValue && !measurementValue_.Equals(other.measurementValue_))) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("measurementId", hasMeasurementId, measurementId_, writer);
          PrintField("measurementValue", hasMeasurementValue, measurementValue_, writer);
        }
        #endregion
        
        public static Measurement ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Measurement ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Measurement ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Measurement ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Measurement ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Measurement ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Measurement ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Measurement ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Measurement ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Measurement ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Measurement MakeReadOnly() {
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Measurement prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilderLite<Measurement, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(Measurement cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Measurement result;
          
          private Measurement PrepareBuilder() {
            if (resultIsReadOnly) {
              Measurement original = result;
              result = new Measurement();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override Measurement MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override Measurement DefaultInstanceForType {
            get { return global::Microsoft.OpenIoT.OpenIoT.Types.Measurement.DefaultInstance; }
          }
          
          public override Measurement BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is Measurement) {
              return MergeFrom((Measurement) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(Measurement other) {
            if (other == global::Microsoft.OpenIoT.OpenIoT.Types.Measurement.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasMeasurementId) {
              MeasurementId = other.MeasurementId;
            }
            if (other.HasMeasurementValue) {
              MeasurementValue = other.MeasurementValue;
            }
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_measurementFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _measurementFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasMeasurementId = input.ReadString(ref result.measurementId_);
                  break;
                }
                case 17: {
                  result.hasMeasurementValue = input.ReadDouble(ref result.measurementValue_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasMeasurementId {
            get { return result.hasMeasurementId; }
          }
          public string MeasurementId {
            get { return result.MeasurementId; }
            set { SetMeasurementId(value); }
          }
          public Builder SetMeasurementId(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasMeasurementId = true;
            result.measurementId_ = value;
            return this;
          }
          public Builder ClearMeasurementId() {
            PrepareBuilder();
            result.hasMeasurementId = false;
            result.measurementId_ = "";
            return this;
          }
          
          public bool HasMeasurementValue {
            get { return result.hasMeasurementValue; }
          }
          public double MeasurementValue {
            get { return result.MeasurementValue; }
            set { SetMeasurementValue(value); }
          }
          public Builder SetMeasurementValue(double value) {
            PrepareBuilder();
            result.hasMeasurementValue = true;
            result.measurementValue_ = value;
            return this;
          }
          public Builder ClearMeasurementValue() {
            PrepareBuilder();
            result.hasMeasurementValue = false;
            result.measurementValue_ = 0D;
            return this;
          }
        }
        static Measurement() {
          object.ReferenceEquals(global::Microsoft.OpenIoT.OpenIoTProto.Descriptor, null);
        }
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class DeviceMeasurements : pb::GeneratedMessageLite<DeviceMeasurements, DeviceMeasurements.Builder> {
        private DeviceMeasurements() { }
        private static readonly DeviceMeasurements defaultInstance = new DeviceMeasurements().MakeReadOnly();
        private static readonly string[] _deviceMeasurementsFieldNames = new string[] { "eventDate", "hardwareId", "measurement", "metadata" };
        private static readonly uint[] _deviceMeasurementsFieldTags = new uint[] { 25, 10, 18, 34 };
        public static DeviceMeasurements DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override DeviceMeasurements DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override DeviceMeasurements ThisMessage {
          get { return this; }
        }
        
        public const int HardwareIdFieldNumber = 1;
        private bool hasHardwareId;
        private string hardwareId_ = "";
        public bool HasHardwareId {
          get { return hasHardwareId; }
        }
        public string HardwareId {
          get { return hardwareId_; }
        }
        
        public const int MeasurementFieldNumber = 2;
        private pbc::PopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Measurement> measurement_ = new pbc::PopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Measurement>();
        public scg::IList<global::Microsoft.OpenIoT.OpenIoT.Types.Measurement> MeasurementList {
          get { return measurement_; }
        }
        public int MeasurementCount {
          get { return measurement_.Count; }
        }
        public global::Microsoft.OpenIoT.OpenIoT.Types.Measurement GetMeasurement(int index) {
          return measurement_[index];
        }
        
        public const int EventDateFieldNumber = 3;
        private bool hasEventDate;
        private ulong eventDate_;
        public bool HasEventDate {
          get { return hasEventDate; }
        }
        [global::System.CLSCompliant(false)]
        public ulong EventDate {
          get { return eventDate_; }
        }
        
        public const int MetadataFieldNumber = 4;
        private pbc::PopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> metadata_ = new pbc::PopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata>();
        public scg::IList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> MetadataList {
          get { return metadata_; }
        }
        public int MetadataCount {
          get { return metadata_.Count; }
        }
        public global::Microsoft.OpenIoT.OpenIoT.Types.Metadata GetMetadata(int index) {
          return metadata_[index];
        }
        
        public override bool IsInitialized {
          get {
            if (!hasHardwareId) return false;
            foreach (global::Microsoft.OpenIoT.OpenIoT.Types.Measurement element in MeasurementList) {
              if (!element.IsInitialized) return false;
            }
            foreach (global::Microsoft.OpenIoT.OpenIoT.Types.Metadata element in MetadataList) {
              if (!element.IsInitialized) return false;
            }
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _deviceMeasurementsFieldNames;
          if (hasHardwareId) {
            output.WriteString(1, field_names[1], HardwareId);
          }
          if (measurement_.Count > 0) {
            output.WriteMessageArray(2, field_names[2], measurement_);
          }
          if (hasEventDate) {
            output.WriteFixed64(3, field_names[0], EventDate);
          }
          if (metadata_.Count > 0) {
            output.WriteMessageArray(4, field_names[3], metadata_);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasHardwareId) {
              size += pb::CodedOutputStream.ComputeStringSize(1, HardwareId);
            }
            foreach (global::Microsoft.OpenIoT.OpenIoT.Types.Measurement element in MeasurementList) {
              size += pb::CodedOutputStream.ComputeMessageSize(2, element);
            }
            if (hasEventDate) {
              size += pb::CodedOutputStream.ComputeFixed64Size(3, EventDate);
            }
            foreach (global::Microsoft.OpenIoT.OpenIoT.Types.Metadata element in MetadataList) {
              size += pb::CodedOutputStream.ComputeMessageSize(4, element);
            }
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasHardwareId) hash ^= hardwareId_.GetHashCode();
          foreach(global::Microsoft.OpenIoT.OpenIoT.Types.Measurement i in measurement_)
            hash ^= i.GetHashCode();
          if (hasEventDate) hash ^= eventDate_.GetHashCode();
          foreach(global::Microsoft.OpenIoT.OpenIoT.Types.Metadata i in metadata_)
            hash ^= i.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          DeviceMeasurements other = obj as DeviceMeasurements;
          if (other == null) return false;
          if (hasHardwareId != other.hasHardwareId || (hasHardwareId && !hardwareId_.Equals(other.hardwareId_))) return false;
          if(measurement_.Count != other.measurement_.Count) return false;
          for(int ix=0; ix < measurement_.Count; ix++)
            if(!measurement_[ix].Equals(other.measurement_[ix])) return false;
          if (hasEventDate != other.hasEventDate || (hasEventDate && !eventDate_.Equals(other.eventDate_))) return false;
          if(metadata_.Count != other.metadata_.Count) return false;
          for(int ix=0; ix < metadata_.Count; ix++)
            if(!metadata_[ix].Equals(other.metadata_[ix])) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("hardwareId", hasHardwareId, hardwareId_, writer);
          PrintField("measurement", measurement_, writer);
          PrintField("eventDate", hasEventDate, eventDate_, writer);
          PrintField("metadata", metadata_, writer);
        }
        #endregion
        
        public static DeviceMeasurements ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static DeviceMeasurements ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static DeviceMeasurements ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static DeviceMeasurements ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static DeviceMeasurements ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static DeviceMeasurements ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static DeviceMeasurements ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static DeviceMeasurements ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static DeviceMeasurements ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static DeviceMeasurements ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private DeviceMeasurements MakeReadOnly() {
          measurement_.MakeReadOnly();
          metadata_.MakeReadOnly();
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(DeviceMeasurements prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilderLite<DeviceMeasurements, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(DeviceMeasurements cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private DeviceMeasurements result;
          
          private DeviceMeasurements PrepareBuilder() {
            if (resultIsReadOnly) {
              DeviceMeasurements original = result;
              result = new DeviceMeasurements();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override DeviceMeasurements MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override DeviceMeasurements DefaultInstanceForType {
            get { return global::Microsoft.OpenIoT.OpenIoT.Types.DeviceMeasurements.DefaultInstance; }
          }
          
          public override DeviceMeasurements BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is DeviceMeasurements) {
              return MergeFrom((DeviceMeasurements) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(DeviceMeasurements other) {
            if (other == global::Microsoft.OpenIoT.OpenIoT.Types.DeviceMeasurements.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasHardwareId) {
              HardwareId = other.HardwareId;
            }
            if (other.measurement_.Count != 0) {
              result.measurement_.Add(other.measurement_);
            }
            if (other.HasEventDate) {
              EventDate = other.EventDate;
            }
            if (other.metadata_.Count != 0) {
              result.metadata_.Add(other.metadata_);
            }
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_deviceMeasurementsFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _deviceMeasurementsFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 10: {
                  result.hasHardwareId = input.ReadString(ref result.hardwareId_);
                  break;
                }
                case 18: {
                  input.ReadMessageArray(tag, field_name, result.measurement_, global::Microsoft.OpenIoT.OpenIoT.Types.Measurement.DefaultInstance, extensionRegistry);
                  break;
                }
                case 25: {
                  result.hasEventDate = input.ReadFixed64(ref result.eventDate_);
                  break;
                }
                case 34: {
                  input.ReadMessageArray(tag, field_name, result.metadata_, global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.DefaultInstance, extensionRegistry);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasHardwareId {
            get { return result.hasHardwareId; }
          }
          public string HardwareId {
            get { return result.HardwareId; }
            set { SetHardwareId(value); }
          }
          public Builder SetHardwareId(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasHardwareId = true;
            result.hardwareId_ = value;
            return this;
          }
          public Builder ClearHardwareId() {
            PrepareBuilder();
            result.hasHardwareId = false;
            result.hardwareId_ = "";
            return this;
          }
          
          public pbc::IPopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Measurement> MeasurementList {
            get { return PrepareBuilder().measurement_; }
          }
          public int MeasurementCount {
            get { return result.MeasurementCount; }
          }
          public global::Microsoft.OpenIoT.OpenIoT.Types.Measurement GetMeasurement(int index) {
            return result.GetMeasurement(index);
          }
          public Builder SetMeasurement(int index, global::Microsoft.OpenIoT.OpenIoT.Types.Measurement value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.measurement_[index] = value;
            return this;
          }
          public Builder SetMeasurement(int index, global::Microsoft.OpenIoT.OpenIoT.Types.Measurement.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.measurement_[index] = builderForValue.Build();
            return this;
          }
          public Builder AddMeasurement(global::Microsoft.OpenIoT.OpenIoT.Types.Measurement value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.measurement_.Add(value);
            return this;
          }
          public Builder AddMeasurement(global::Microsoft.OpenIoT.OpenIoT.Types.Measurement.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.measurement_.Add(builderForValue.Build());
            return this;
          }
          public Builder AddRangeMeasurement(scg::IEnumerable<global::Microsoft.OpenIoT.OpenIoT.Types.Measurement> values) {
            PrepareBuilder();
            result.measurement_.Add(values);
            return this;
          }
          public Builder ClearMeasurement() {
            PrepareBuilder();
            result.measurement_.Clear();
            return this;
          }
          
          public bool HasEventDate {
            get { return result.hasEventDate; }
          }
          [global::System.CLSCompliant(false)]
          public ulong EventDate {
            get { return result.EventDate; }
            set { SetEventDate(value); }
          }
          [global::System.CLSCompliant(false)]
          public Builder SetEventDate(ulong value) {
            PrepareBuilder();
            result.hasEventDate = true;
            result.eventDate_ = value;
            return this;
          }
          public Builder ClearEventDate() {
            PrepareBuilder();
            result.hasEventDate = false;
            result.eventDate_ = 0;
            return this;
          }
          
          public pbc::IPopsicleList<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> MetadataList {
            get { return PrepareBuilder().metadata_; }
          }
          public int MetadataCount {
            get { return result.MetadataCount; }
          }
          public global::Microsoft.OpenIoT.OpenIoT.Types.Metadata GetMetadata(int index) {
            return result.GetMetadata(index);
          }
          public Builder SetMetadata(int index, global::Microsoft.OpenIoT.OpenIoT.Types.Metadata value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.metadata_[index] = value;
            return this;
          }
          public Builder SetMetadata(int index, global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.metadata_[index] = builderForValue.Build();
            return this;
          }
          public Builder AddMetadata(global::Microsoft.OpenIoT.OpenIoT.Types.Metadata value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.metadata_.Add(value);
            return this;
          }
          public Builder AddMetadata(global::Microsoft.OpenIoT.OpenIoT.Types.Metadata.Builder builderForValue) {
            pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
            PrepareBuilder();
            result.metadata_.Add(builderForValue.Build());
            return this;
          }
          public Builder AddRangeMetadata(scg::IEnumerable<global::Microsoft.OpenIoT.OpenIoT.Types.Metadata> values) {
            PrepareBuilder();
            result.metadata_.Add(values);
            return this;
          }
          public Builder ClearMetadata() {
            PrepareBuilder();
            result.metadata_.Clear();
            return this;
          }
        }
        static DeviceMeasurements() {
          object.ReferenceEquals(global::Microsoft.OpenIoT.OpenIoTProto.Descriptor, null);
        }
      }
      
    }
    #endregion
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _openIoTFieldNames;
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      OpenIoT other = obj as OpenIoT;
      if (other == null) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
    }
    #endregion
    
    public static OpenIoT ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OpenIoT ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OpenIoT ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OpenIoT ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OpenIoT ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OpenIoT ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static OpenIoT ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static OpenIoT ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static OpenIoT ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OpenIoT ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private OpenIoT MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(OpenIoT prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<OpenIoT, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(OpenIoT cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private OpenIoT result;
      
      private OpenIoT PrepareBuilder() {
        if (resultIsReadOnly) {
          OpenIoT original = result;
          result = new OpenIoT();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override OpenIoT MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override OpenIoT DefaultInstanceForType {
        get { return global::Microsoft.OpenIoT.OpenIoT.DefaultInstance; }
      }
      
      public override OpenIoT BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is OpenIoT) {
          return MergeFrom((OpenIoT) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(OpenIoT other) {
        if (other == global::Microsoft.OpenIoT.OpenIoT.DefaultInstance) return this;
        PrepareBuilder();
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_openIoTFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _openIoTFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        return this;
      }
      
    }
    static OpenIoT() {
      object.ReferenceEquals(global::Microsoft.OpenIoT.OpenIoTProto.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Device : pb::GeneratedMessageLite<Device, Device.Builder> {
    private Device() { }
    private static readonly Device defaultInstance = new Device().MakeReadOnly();
    private static readonly string[] _deviceFieldNames = new string[] {  };
    private static readonly uint[] _deviceFieldTags = new uint[] {  };
    public static Device DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Device DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Device ThisMessage {
      get { return this; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum Command {
        REGISTER_ACK = 1,
      }
      
      public enum RegistrationAckState {
        NEW_REGISTRATION = 1,
        ALREADY_REGISTERED = 2,
        REGISTRATION_ERROR = 3,
      }
      
      public enum RegistrationAckError {
        INVALID_SPECIFICATION = 1,
        SITE_TOKEN_REQUIRED = 2,
        NEW_DEVICES_NOT_ALLOWED = 3,
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Header : pb::GeneratedMessageLite<Header, Header.Builder> {
        private Header() { }
        private static readonly Header defaultInstance = new Header().MakeReadOnly();
        private static readonly string[] _headerFieldNames = new string[] { "command", "nestedPath", "nestedSpec", "originator" };
        private static readonly uint[] _headerFieldTags = new uint[] { 8, 26, 34, 18 };
        public static Header DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override Header DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override Header ThisMessage {
          get { return this; }
        }
        
        public const int CommandFieldNumber = 1;
        private bool hasCommand;
        private global::Microsoft.OpenIoT.Device.Types.Command command_ = global::Microsoft.OpenIoT.Device.Types.Command.REGISTER_ACK;
        public bool HasCommand {
          get { return hasCommand; }
        }
        public global::Microsoft.OpenIoT.Device.Types.Command Command {
          get { return command_; }
        }
        
        public const int OriginatorFieldNumber = 2;
        private bool hasOriginator;
        private string originator_ = "";
        public bool HasOriginator {
          get { return hasOriginator; }
        }
        public string Originator {
          get { return originator_; }
        }
        
        public const int NestedPathFieldNumber = 3;
        private bool hasNestedPath;
        private string nestedPath_ = "";
        public bool HasNestedPath {
          get { return hasNestedPath; }
        }
        public string NestedPath {
          get { return nestedPath_; }
        }
        
        public const int NestedSpecFieldNumber = 4;
        private bool hasNestedSpec;
        private string nestedSpec_ = "";
        public bool HasNestedSpec {
          get { return hasNestedSpec; }
        }
        public string NestedSpec {
          get { return nestedSpec_; }
        }
        
        public override bool IsInitialized {
          get {
            if (!hasCommand) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _headerFieldNames;
          if (hasCommand) {
            output.WriteEnum(1, field_names[0], (int) Command, Command);
          }
          if (hasOriginator) {
            output.WriteString(2, field_names[3], Originator);
          }
          if (hasNestedPath) {
            output.WriteString(3, field_names[1], NestedPath);
          }
          if (hasNestedSpec) {
            output.WriteString(4, field_names[2], NestedSpec);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasCommand) {
              size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Command);
            }
            if (hasOriginator) {
              size += pb::CodedOutputStream.ComputeStringSize(2, Originator);
            }
            if (hasNestedPath) {
              size += pb::CodedOutputStream.ComputeStringSize(3, NestedPath);
            }
            if (hasNestedSpec) {
              size += pb::CodedOutputStream.ComputeStringSize(4, NestedSpec);
            }
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasCommand) hash ^= command_.GetHashCode();
          if (hasOriginator) hash ^= originator_.GetHashCode();
          if (hasNestedPath) hash ^= nestedPath_.GetHashCode();
          if (hasNestedSpec) hash ^= nestedSpec_.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          Header other = obj as Header;
          if (other == null) return false;
          if (hasCommand != other.hasCommand || (hasCommand && !command_.Equals(other.command_))) return false;
          if (hasOriginator != other.hasOriginator || (hasOriginator && !originator_.Equals(other.originator_))) return false;
          if (hasNestedPath != other.hasNestedPath || (hasNestedPath && !nestedPath_.Equals(other.nestedPath_))) return false;
          if (hasNestedSpec != other.hasNestedSpec || (hasNestedSpec && !nestedSpec_.Equals(other.nestedSpec_))) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("command", hasCommand, command_, writer);
          PrintField("originator", hasOriginator, originator_, writer);
          PrintField("nestedPath", hasNestedPath, nestedPath_, writer);
          PrintField("nestedSpec", hasNestedSpec, nestedSpec_, writer);
        }
        #endregion
        
        public static Header ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Header ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Header ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static Header ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static Header ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Header ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static Header ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static Header ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static Header ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static Header ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private Header MakeReadOnly() {
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(Header prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilderLite<Header, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(Header cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private Header result;
          
          private Header PrepareBuilder() {
            if (resultIsReadOnly) {
              Header original = result;
              result = new Header();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override Header MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override Header DefaultInstanceForType {
            get { return global::Microsoft.OpenIoT.Device.Types.Header.DefaultInstance; }
          }
          
          public override Header BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is Header) {
              return MergeFrom((Header) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(Header other) {
            if (other == global::Microsoft.OpenIoT.Device.Types.Header.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasCommand) {
              Command = other.Command;
            }
            if (other.HasOriginator) {
              Originator = other.Originator;
            }
            if (other.HasNestedPath) {
              NestedPath = other.NestedPath;
            }
            if (other.HasNestedSpec) {
              NestedSpec = other.NestedSpec;
            }
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_headerFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _headerFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 8: {
                  object unknown;
                  if(input.ReadEnum(ref result.command_, out unknown)) {
                    result.hasCommand = true;
                  } else if(unknown is int) {
                  }
                  break;
                }
                case 18: {
                  result.hasOriginator = input.ReadString(ref result.originator_);
                  break;
                }
                case 26: {
                  result.hasNestedPath = input.ReadString(ref result.nestedPath_);
                  break;
                }
                case 34: {
                  result.hasNestedSpec = input.ReadString(ref result.nestedSpec_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasCommand {
           get { return result.hasCommand; }
          }
          public global::Microsoft.OpenIoT.Device.Types.Command Command {
            get { return result.Command; }
            set { SetCommand(value); }
          }
          public Builder SetCommand(global::Microsoft.OpenIoT.Device.Types.Command value) {
            PrepareBuilder();
            result.hasCommand = true;
            result.command_ = value;
            return this;
          }
          public Builder ClearCommand() {
            PrepareBuilder();
            result.hasCommand = false;
            result.command_ = global::Microsoft.OpenIoT.Device.Types.Command.REGISTER_ACK;
            return this;
          }
          
          public bool HasOriginator {
            get { return result.hasOriginator; }
          }
          public string Originator {
            get { return result.Originator; }
            set { SetOriginator(value); }
          }
          public Builder SetOriginator(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasOriginator = true;
            result.originator_ = value;
            return this;
          }
          public Builder ClearOriginator() {
            PrepareBuilder();
            result.hasOriginator = false;
            result.originator_ = "";
            return this;
          }
          
          public bool HasNestedPath {
            get { return result.hasNestedPath; }
          }
          public string NestedPath {
            get { return result.NestedPath; }
            set { SetNestedPath(value); }
          }
          public Builder SetNestedPath(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasNestedPath = true;
            result.nestedPath_ = value;
            return this;
          }
          public Builder ClearNestedPath() {
            PrepareBuilder();
            result.hasNestedPath = false;
            result.nestedPath_ = "";
            return this;
          }
          
          public bool HasNestedSpec {
            get { return result.hasNestedSpec; }
          }
          public string NestedSpec {
            get { return result.NestedSpec; }
            set { SetNestedSpec(value); }
          }
          public Builder SetNestedSpec(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasNestedSpec = true;
            result.nestedSpec_ = value;
            return this;
          }
          public Builder ClearNestedSpec() {
            PrepareBuilder();
            result.hasNestedSpec = false;
            result.nestedSpec_ = "";
            return this;
          }
        }
        static Header() {
          object.ReferenceEquals(global::Microsoft.OpenIoT.OpenIoTProto.Descriptor, null);
        }
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class RegistrationAck : pb::GeneratedMessageLite<RegistrationAck, RegistrationAck.Builder> {
        private RegistrationAck() { }
        private static readonly RegistrationAck defaultInstance = new RegistrationAck().MakeReadOnly();
        private static readonly string[] _registrationAckFieldNames = new string[] { "errorMessage", "errorType", "state" };
        private static readonly uint[] _registrationAckFieldTags = new uint[] { 26, 16, 8 };
        public static RegistrationAck DefaultInstance {
          get { return defaultInstance; }
        }
        
        public override RegistrationAck DefaultInstanceForType {
          get { return DefaultInstance; }
        }
        
        protected override RegistrationAck ThisMessage {
          get { return this; }
        }
        
        public const int StateFieldNumber = 1;
        private bool hasState;
        private global::Microsoft.OpenIoT.Device.Types.RegistrationAckState state_ = global::Microsoft.OpenIoT.Device.Types.RegistrationAckState.NEW_REGISTRATION;
        public bool HasState {
          get { return hasState; }
        }
        public global::Microsoft.OpenIoT.Device.Types.RegistrationAckState State {
          get { return state_; }
        }
        
        public const int ErrorTypeFieldNumber = 2;
        private bool hasErrorType;
        private global::Microsoft.OpenIoT.Device.Types.RegistrationAckError errorType_ = global::Microsoft.OpenIoT.Device.Types.RegistrationAckError.INVALID_SPECIFICATION;
        public bool HasErrorType {
          get { return hasErrorType; }
        }
        public global::Microsoft.OpenIoT.Device.Types.RegistrationAckError ErrorType {
          get { return errorType_; }
        }
        
        public const int ErrorMessageFieldNumber = 3;
        private bool hasErrorMessage;
        private string errorMessage_ = "";
        public bool HasErrorMessage {
          get { return hasErrorMessage; }
        }
        public string ErrorMessage {
          get { return errorMessage_; }
        }
        
        public override bool IsInitialized {
          get {
            if (!hasState) return false;
            return true;
          }
        }
        
        public override void WriteTo(pb::ICodedOutputStream output) {
          int size = SerializedSize;
          string[] field_names = _registrationAckFieldNames;
          if (hasState) {
            output.WriteEnum(1, field_names[2], (int) State, State);
          }
          if (hasErrorType) {
            output.WriteEnum(2, field_names[1], (int) ErrorType, ErrorType);
          }
          if (hasErrorMessage) {
            output.WriteString(3, field_names[0], ErrorMessage);
          }
        }
        
        private int memoizedSerializedSize = -1;
        public override int SerializedSize {
          get {
            int size = memoizedSerializedSize;
            if (size != -1) return size;
            
            size = 0;
            if (hasState) {
              size += pb::CodedOutputStream.ComputeEnumSize(1, (int) State);
            }
            if (hasErrorType) {
              size += pb::CodedOutputStream.ComputeEnumSize(2, (int) ErrorType);
            }
            if (hasErrorMessage) {
              size += pb::CodedOutputStream.ComputeStringSize(3, ErrorMessage);
            }
            memoizedSerializedSize = size;
            return size;
          }
        }
        
        #region Lite runtime methods
        public override int GetHashCode() {
          int hash = GetType().GetHashCode();
          if (hasState) hash ^= state_.GetHashCode();
          if (hasErrorType) hash ^= errorType_.GetHashCode();
          if (hasErrorMessage) hash ^= errorMessage_.GetHashCode();
          return hash;
        }
        
        public override bool Equals(object obj) {
          RegistrationAck other = obj as RegistrationAck;
          if (other == null) return false;
          if (hasState != other.hasState || (hasState && !state_.Equals(other.state_))) return false;
          if (hasErrorType != other.hasErrorType || (hasErrorType && !errorType_.Equals(other.errorType_))) return false;
          if (hasErrorMessage != other.hasErrorMessage || (hasErrorMessage && !errorMessage_.Equals(other.errorMessage_))) return false;
          return true;
        }
        
        public override void PrintTo(global::System.IO.TextWriter writer) {
          PrintField("state", hasState, state_, writer);
          PrintField("errorType", hasErrorType, errorType_, writer);
          PrintField("errorMessage", hasErrorMessage, errorMessage_, writer);
        }
        #endregion
        
        public static RegistrationAck ParseFrom(pb::ByteString data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static RegistrationAck ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static RegistrationAck ParseFrom(byte[] data) {
          return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
        }
        public static RegistrationAck ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
        }
        public static RegistrationAck ParseFrom(global::System.IO.Stream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static RegistrationAck ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        public static RegistrationAck ParseDelimitedFrom(global::System.IO.Stream input) {
          return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
        }
        public static RegistrationAck ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
          return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
        }
        public static RegistrationAck ParseFrom(pb::ICodedInputStream input) {
          return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
        }
        public static RegistrationAck ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
        }
        private RegistrationAck MakeReadOnly() {
          return this;
        }
        
        public static Builder CreateBuilder() { return new Builder(); }
        public override Builder ToBuilder() { return CreateBuilder(this); }
        public override Builder CreateBuilderForType() { return new Builder(); }
        public static Builder CreateBuilder(RegistrationAck prototype) {
          return new Builder(prototype);
        }
        
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
        public sealed partial class Builder : pb::GeneratedBuilderLite<RegistrationAck, Builder> {
          protected override Builder ThisBuilder {
            get { return this; }
          }
          public Builder() {
            result = DefaultInstance;
            resultIsReadOnly = true;
          }
          internal Builder(RegistrationAck cloneFrom) {
            result = cloneFrom;
            resultIsReadOnly = true;
          }
          
          private bool resultIsReadOnly;
          private RegistrationAck result;
          
          private RegistrationAck PrepareBuilder() {
            if (resultIsReadOnly) {
              RegistrationAck original = result;
              result = new RegistrationAck();
              resultIsReadOnly = false;
              MergeFrom(original);
            }
            return result;
          }
          
          public override bool IsInitialized {
            get { return result.IsInitialized; }
          }
          
          protected override RegistrationAck MessageBeingBuilt {
            get { return PrepareBuilder(); }
          }
          
          public override Builder Clear() {
            result = DefaultInstance;
            resultIsReadOnly = true;
            return this;
          }
          
          public override Builder Clone() {
            if (resultIsReadOnly) {
              return new Builder(result);
            } else {
              return new Builder().MergeFrom(result);
            }
          }
          
          public override RegistrationAck DefaultInstanceForType {
            get { return global::Microsoft.OpenIoT.Device.Types.RegistrationAck.DefaultInstance; }
          }
          
          public override RegistrationAck BuildPartial() {
            if (resultIsReadOnly) {
              return result;
            }
            resultIsReadOnly = true;
            return result.MakeReadOnly();
          }
          
          public override Builder MergeFrom(pb::IMessageLite other) {
            if (other is RegistrationAck) {
              return MergeFrom((RegistrationAck) other);
            } else {
              base.MergeFrom(other);
              return this;
            }
          }
          
          public override Builder MergeFrom(RegistrationAck other) {
            if (other == global::Microsoft.OpenIoT.Device.Types.RegistrationAck.DefaultInstance) return this;
            PrepareBuilder();
            if (other.HasState) {
              State = other.State;
            }
            if (other.HasErrorType) {
              ErrorType = other.ErrorType;
            }
            if (other.HasErrorMessage) {
              ErrorMessage = other.ErrorMessage;
            }
            return this;
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input) {
            return MergeFrom(input, pb::ExtensionRegistry.Empty);
          }
          
          public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
            PrepareBuilder();
            uint tag;
            string field_name;
            while (input.ReadTag(out tag, out field_name)) {
              if(tag == 0 && field_name != null) {
                int field_ordinal = global::System.Array.BinarySearch(_registrationAckFieldNames, field_name, global::System.StringComparer.Ordinal);
                if(field_ordinal >= 0)
                  tag = _registrationAckFieldTags[field_ordinal];
                else {
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  continue;
                }
              }
              switch (tag) {
                case 0: {
                  throw pb::InvalidProtocolBufferException.InvalidTag();
                }
                default: {
                  if (pb::WireFormat.IsEndGroupTag(tag)) {
                    return this;
                  }
                  ParseUnknownField(input, extensionRegistry, tag, field_name);
                  break;
                }
                case 8: {
                  object unknown;
                  if(input.ReadEnum(ref result.state_, out unknown)) {
                    result.hasState = true;
                  } else if(unknown is int) {
                  }
                  break;
                }
                case 16: {
                  object unknown;
                  if(input.ReadEnum(ref result.errorType_, out unknown)) {
                    result.hasErrorType = true;
                  } else if(unknown is int) {
                  }
                  break;
                }
                case 26: {
                  result.hasErrorMessage = input.ReadString(ref result.errorMessage_);
                  break;
                }
              }
            }
            
            return this;
          }
          
          
          public bool HasState {
           get { return result.hasState; }
          }
          public global::Microsoft.OpenIoT.Device.Types.RegistrationAckState State {
            get { return result.State; }
            set { SetState(value); }
          }
          public Builder SetState(global::Microsoft.OpenIoT.Device.Types.RegistrationAckState value) {
            PrepareBuilder();
            result.hasState = true;
            result.state_ = value;
            return this;
          }
          public Builder ClearState() {
            PrepareBuilder();
            result.hasState = false;
            result.state_ = global::Microsoft.OpenIoT.Device.Types.RegistrationAckState.NEW_REGISTRATION;
            return this;
          }
          
          public bool HasErrorType {
           get { return result.hasErrorType; }
          }
          public global::Microsoft.OpenIoT.Device.Types.RegistrationAckError ErrorType {
            get { return result.ErrorType; }
            set { SetErrorType(value); }
          }
          public Builder SetErrorType(global::Microsoft.OpenIoT.Device.Types.RegistrationAckError value) {
            PrepareBuilder();
            result.hasErrorType = true;
            result.errorType_ = value;
            return this;
          }
          public Builder ClearErrorType() {
            PrepareBuilder();
            result.hasErrorType = false;
            result.errorType_ = global::Microsoft.OpenIoT.Device.Types.RegistrationAckError.INVALID_SPECIFICATION;
            return this;
          }
          
          public bool HasErrorMessage {
            get { return result.hasErrorMessage; }
          }
          public string ErrorMessage {
            get { return result.ErrorMessage; }
            set { SetErrorMessage(value); }
          }
          public Builder SetErrorMessage(string value) {
            pb::ThrowHelper.ThrowIfNull(value, "value");
            PrepareBuilder();
            result.hasErrorMessage = true;
            result.errorMessage_ = value;
            return this;
          }
          public Builder ClearErrorMessage() {
            PrepareBuilder();
            result.hasErrorMessage = false;
            result.errorMessage_ = "";
            return this;
          }
        }
        static RegistrationAck() {
          object.ReferenceEquals(global::Microsoft.OpenIoT.OpenIoTProto.Descriptor, null);
        }
      }
      
    }
    #endregion
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _deviceFieldNames;
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      Device other = obj as Device;
      if (other == null) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
    }
    #endregion
    
    public static Device ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Device ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Device ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Device ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Device ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Device ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Device ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Device ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Device ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Device ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Device MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Device prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilderLite<Device, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Device cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Device result;
      
      private Device PrepareBuilder() {
        if (resultIsReadOnly) {
          Device original = result;
          result = new Device();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Device MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override Device DefaultInstanceForType {
        get { return global::Microsoft.OpenIoT.Device.DefaultInstance; }
      }
      
      public override Device BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessageLite other) {
        if (other is Device) {
          return MergeFrom((Device) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Device other) {
        if (other == global::Microsoft.OpenIoT.Device.DefaultInstance) return this;
        PrepareBuilder();
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_deviceFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _deviceFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        return this;
      }
      
    }
    static Device() {
      object.ReferenceEquals(global::Microsoft.OpenIoT.OpenIoTProto.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
